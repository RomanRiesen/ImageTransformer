<!DOCTYPE html>
<meta 
     content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' 
/>
<html lang="en">
  <title>Image Transformer</title>
  <head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta charset=utf-8>
    <meta name="Description" content="Tool to play around with conformal mappings and images to create funny pictures and distortions.">
    <meta name="theme-color" content="#FFA500"/>
    <link rel="manifest" href="manifest.json">
    <link rel="shortcut icon" href="img/icon.png">
    <link async rel="stylesheet" id="quicksettings_style" href="css/quicksettings_default.css">
    <link async rel="stylesheet" href="style.css">
    <script language="javascript" src="js/quicksettings.min.js"></script>
    <script language="javascript" src="transformer_shaders.js"></script>
    <script defer language="javascript" src="js/regl.min.js"></script>
    <script defer language="javascript" src="js/hammer.min.js"></script>
    <script defer language="javascript" src="js/gif.js"></script>
    <script defer language="javascript" src="js/download.js"></script>
  </head>

  <body>
  <!--
    <body ondrop = e => {e.preventDefault(); e.stopPropagation(); fileSelected(e);}
  -->
    
    <noscript><h1>Javascript is required!</h1></noscript>

    <canvas id="reglCanvas"> </canvas>
    <canvas id="gifCanvas" hidden> </canvas>
    <img id="gifResult"></img>
  </body>

  <script language="javascript">

//'globals'
const to_rad = r => {return r/180*Math.PI}
const touch_pinch_factor = 1
let current_scale = [1,1]
let base_scale = [1,1]
let current_rotation = 0 //0 to 2PI
let base_rotation = 0
let current_panning = [0,0] 
let base_panning = [0,0] 

let draw = ()=>{}//later gets filled in. super weird and quite bad...


window.onload = function() {

  var reglCanvas = document.getElementById('reglCanvas')
  function resizeCanvas() {
    reglCanvas.width = window.innerWidth
    reglCanvas.height = window.innerHeight
  };

  window.onresize = resizeCanvas
  resizeCanvas()


  var hammertime = new Hammer(reglCanvas)
  hammertime.get('pan').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  //hammertime.get('swipe').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  hammertime.get('pinch').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  hammertime.get('rotate').set({ enable: true, direction: Hammer.DIRECTION_ALL, threshold: 10 })

  var ignore_next_pan = false;
  //var _pinch = new Hammer.Pinch()
  //var _rotate = new Hammer.Rotate()
  //var _pan = new Hammer.Pan()
  //_pinch.recognizeWith(_rotate)
  //_pinch.recognizeWith(_pan)

  hammertime.on('pan', function(ev) {
    if(ignore_next_pan) return;
    d = ev.distance
    current_panning[0] = base_panning[0]+Math.cos(to_rad(ev.angle))*d
    current_panning[1] = base_panning[1]-Math.sin(to_rad(ev.angle))*d
  });

  hammertime.on('panend', function(ev) {
    if(ignore_next_pan) {ignore_next_pan = false; return;}
    d = ev.distance
    base_panning[0] += Math.cos(to_rad(ev.angle))*d
    base_panning[1] -= Math.sin(to_rad(ev.angle))*d
  });

  hammertime.on('pinchmove', function(ev) {
    current_scale[0] = current_scale[1] = base_scale[0] * 1/ev.scale
    //current_scale[1] = base_scale[1] * 1/ev.scale
    //current_panning[0] *= ev.scale
    //current_panning[1] *= ev.scale
  });

  hammertime.on('pinchend', function(ev) {
    base_scale[0] = base_scale[1] *= 1/ev.scale
    //base_panning[0] *= ev.scale 
    //base_panning[1] *= ev.scale
    ignore_next_pan = true;
  });

  hammertime.on('rotatemove', function(ev) {
    current_rotation = ev.angle
  });

  hammertime.on('rotateend', function(ev) {
    base_rotation += ev.angle
    ignore_next_pan = true;
  });


  window.addEventListener("wheel", event => {
    let scroll_wheel_factor = 1/1.05
    let change = event.deltaY < 0 ? scroll_wheel_factor : 1/scroll_wheel_factor
    current_scale[0] *= change
    current_scale[1] *= change
    //current_panning[0] /= change/2
    //current_panning[1] /= change/2
    //base_panning[0] /= change/2
    //base_panning[1] /= change/2
  });

  var gif = new GIF({workers: 4, quality: 30})
  gif.on('finished', function(blob) {
    window.open(URL.createObjectURL(blob));
    document.getElementById("gifResult").src = URL.createObjectURL(blob)
    console.log("Done giffing!")
  });
  gif.on('progress', function(p) {console.log(`${p*100}%`)})


  function buffer_to_canvas(){
    var width = reglCanvas.width
    var height = reglCanvas.height
    var data = regl.read({//This requires preserveDrawingBuffer and is thus pretty slow. Should figure out correct way! maybe use regl._gl
      x: 0,
      y: 0,
      width: width,
      height: height,
      data: new Uint8Array(width*height*4)
    })
    var canv2d = document.getElementById('gifCanvas')
    var context = canv2d.getContext('2d')
    canv2d.width = width
    canv2d.height = height
    var imageData = context.createImageData(width, height)
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0)
    return canv2d
  }

  function addGifFrame(dt, regl){
    gif.addFrame(buffer_to_ctx(), {copy: true, delay: dt})
  }

  function download_buffer(){
    var buffer_image = buffer_to_canvas().toDataURL()
    download(buffer_image, opened_image_name.split(".")[0]+"_conformal_mapped.png");//TODO add original filename?
  }

  draw = (img) =>
  {
  if(img.height == 0)
    return
  
  regl = createREGL(gl)
  //var original_texture = regl.texture(img)
  try {//FIXME instead of failing I shoudl downscale the image!!!
  var new_texture = regl.texture(img)
      new_texture.wrap = 'repeat'
      new_texture.mag = 'nearest'
      new_texture.min = 'nearest'
  } catch (e) {
    let max_texture_size = (gl.getParameter(gl.MAX_TEXTURE_SIZE))
    alert(
        "Maximal supported image size on this device is"+
        `${max_texture_size}x${max_texture_size}.\n`+
        `Your image has size ${img.height}x${img.width}.\n Sorry. Try on a PC.`
      )
  }
  //FIXME should set the canvas height/width ratio equal to the one of the loaded image.


  const crossPattern = regl({
  
    // Shaders in regl are just strings.  You can use glslify or whatever you want
    // to define them.  No need to manually create shader objects.
    frag: vertex_shader.get(settings.getValue("Type").value),
  
    vert: `
      precision mediump float;
      attribute vec2 position;
      varying vec2 uv;
      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
  
    // Here we define the vertex attributes for the above shader
    attributes: {
      // regl.buffer creates a new array buffer object
      position: regl.buffer([
        // no need to flatten nested arrays, regl automatically
        // unrolls them into a typedarray (default Float32)
        [-1, -1],   
        [-1, 1],
        [1, -1],    
        [1, -1],
        [1,  1],
        [-1, 1],
      ])
      // regl automatically infers sane defaults for the vertex attribute pointers
    },
  
    uniforms: {
      // This defines the color of the triangle to be a dynamic variable
      combine_factor: regl.prop('combine_factor'),
      scale_factor: regl.prop('scale_factor'),
      rotation_factor: regl.prop('rotation_factor'),
      pan_factor: regl.prop('pan_factor'),
      //These 2 should be made const...
      u_resolution: regl.prop('u_resolution'),
      radial_splits: regl.prop('radial_splits'),
      texture_const: new_texture,
    },
  
    // This tells regl the number of vertices to draw in this command
    count: 6
  })



  var fps60Gif = false;
  var to_gif = false;
  var i = 0
  var max_i = 5;//Math.floor(Math.PI*60)
  regl.frame(({time}) => {
    // clear contents of the drawing buffer
    //TODO: patch the GIF.JS to use https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels
    //if ctx is webgl/2

    regl.clear({
      color: [1, 0.5, 0, 0],
      depth: 1
    })
  
    crossPattern({
      combine_factor: settings.getValue("Strength"),//parseFloat(document.getElementById("combineRangeInput").value),
      u_resolution: [reglCanvas.width, reglCanvas.height], //not 100% correct
      rotation_factor: to_rad(current_rotation + base_rotation),
      pan_factor: (current_panning),
      scale_factor: current_scale, //current_scale.map(x => {return x*x}) //really bad idea on mobile..
      radial_splits: settings.getValue("Radial Symmetry")
    })

    if (to_gif && i++ < max_i && (i%2 == 0 && !fps60Gif || fps60Gif))
    {
      addGifFrame(fps60Gif ? 16 : 32, regl)
    }
    if(i == max_i)
    {
      console.log("Start giffing...")
      gif.render();
    }})}


    // Calling regl() creates a new partially evaluated draw command
    let img = new Image()
    let gl = reglCanvas.getContext('webgl', {preserveDrawingBuffer: true})
    var regl = createREGL(gl)
    var opened_image_name = ""

}



//QuickSettings stuff

const change_style = e =>
{
  var styleTag = document.getElementById("quicksettings_style");
    styleTag.href = "css/quicksettings_" + e.value + ".css";
    if(e.value.includes("tiny"))
    {
      settings.setWidth("80")
    }
    else
      settings.setSize("120","")
}

const toggleLoading = function(){
    document.getElementById("loadingSpan").toggleAttribute("hidden")
}

const fileSelected = function(e) {
    const t = Date.now()
    const file = e.target.files[0]
    img = new Image()
    let reader = new FileReader()
    opened_image_name = file.name

    reader.readAsDataURL(file)
    reader.onload = e => {img.src = e.target.result}
    toggleLoading()
    img.onload = ()=>{draw(img), console.log((Date.now()-t)/1000), toggleLoading()}
}

QuickSettings.useExtStyleSheet()
var settings = QuickSettings.create(0, 0, "Settings", document.body)
//.setGlobalChangeHandler(()=>(settings.saveInLocalStorage("settings")))
  .addHTML("File",
    "<input id='imageInput' type='file' accept='image/*' class='inputfile' onchange='fileSelected(event)'/>"+
    "<label for='imageInput'>Select Image!</label>"+
    "<span id='loadingSpan' hidden>Loading...</span>"
)
  .addDropDown("Type", Object.keys(vertex_shader.transformer_dict), (e) => {draw(img);})
  .addRange("Strength", 0, 1, 1, 0.01, e => {})
  .addNumber("Radial Symmetry", 1, 1/0, 0, 1, e => {})
  .addButton("Reset Zoom", () => {base_scale = [1,1]; current_scale = [1,1]; base_panning = [0,0]; current_panning = [0,0]})
  .addButton("Save Image", () => {download_buffer()})
  .addDropDown("Style", [
    "default",
	  "white",
	  "black",
	  "tiny_white",
	  "tiny_black"
      ], change_style)
    
change_style({"value":"default"})
settings.hideTitle("File");

console.log(settings)

//var settings_hidden = false;
document.getElementsByClassName("qs_title_bar")[0].ontouchend = e => {
  settings._doubleClickTitle();
  //settings_hidden ? settings._content.style.display = "inherit" : settings._content.style.display = "none";
  //settings_hidden = !settings_hidden;
}

//offline service worker stuff
if('serviceWorker' in navigator) {
  navigator.serviceWorker
           .register('./offline_worker.js')
           .then(function() { console.log("Service Worker Registered"); });
}
</script>
</html>
