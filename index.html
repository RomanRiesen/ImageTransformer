<!DOCTYPE html>
<meta 
     content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' 
/>
<html>
  <head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta charset=utf-8>
    <link rel="stylesheet" id="quicksettings_style" href="css/quicksettings.css">
    <script async language="javascript" src="js/regl.min.js"></script>
    <script language="javascript" src="js/quicksettings.min.js"></script>
    <script language="javascript" src="js/hammer.min.js"></script>
    <script language="javascript" src="js/gif.js"></script>
  </head>
  <body>

    <canvas id="reglCanvas"> </canvas>
    <!--
    <div id = "inputDiv">
        <input id="imageInput" type="file" accept="image/*" class="inputfile" onchange="fileSelected(event)"/>
        <label for="imageInput">Select Image!</label>
        <span class="input_container">
          <span>Type: </span>
          <span>Z^-2</span>
        </span>
        <span class="input_container">
          <span>Strength: </span>
          <input class="slider" type="range"  min = "0", max = "1" value="1" step="0.01" name="Strength" id="combineRangeInput"/> 
        </span>
        <span class="input_container">
          <input type="number" name="split_radially" value="0">Rotation Splits<br>
        </span>
    </div>
    -->

    <canvas id="gifCanvas" hidden> </canvas>
    <img id="gifResult"></img>
  </body>
  <style>
    .inputfile{
      width: 0.1px;
	    height: 0.1px;
	    opacity: 0;
	    overflow: hidden;
	    position: absolute;
	    z-index: -1;  
    }

    .inputfile:focus + label,
    .inputfile + label:hover {
      background-color: orange;
    }

    .inputfile + label{
      margin: auto;
      border: solid;
      border-color: darkgray;
      cursor: pointer;
      display: inline-block;
      background-color: white;
      padding: 5px;
    }

    .inputfile:focus + label {
	    outline: 1px dotted #000;
	    outline: -webkit-focus-ring-color auto 5px;
    }

    .slider {
      margin: auto;
    }

    .input_container {
      border: solid;
      border-color: darkgray;
      border-radius: 10px;
      padding: 5px;
      background: white;
    }

    #inputDiv{
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      background: rgba(200, 200, 200, 0.8);
      padding: 5px;
    }

    #reglCanvvas{
      position: absolute;
      top: 0;
      left: 0;
    }

    body{
      margin: 0;
      overflow: hidden;
    }
  </style>

  <script language="javascript">

  const to_rad = r => {return r/180*Math.PI}
  const touch_pinch_factor = 0.01
  let current_scale = [1,1]
  let base_scale = [1,1]
  let current_rotation = 0 //0 to 2PI
  let base_rotation = 0
  let current_panning = [0,0] 
  let base_panning = [0,0] 

  var reglCanvas = document.getElementById('reglCanvas')
  function resizeCanvas() {
    reglCanvas.width = window.innerWidth
    reglCanvas.height = window.innerHeight
  };

  window.onresize = resizeCanvas
  resizeCanvas()


  var hammertime = new Hammer(reglCanvas)
  hammertime.get('pan').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  //hammertime.get('swipe').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  hammertime.get('pinch').set({ enable: true, direction: Hammer.DIRECTION_ALL })
  hammertime.get('rotate').set({ enable: true, direction: Hammer.DIRECTION_ALL, threshold: 10 })

  var ignore_next_pan = false;
  //var _pinch = new Hammer.Pinch()
  //var _rotate = new Hammer.Rotate()
  //var _pan = new Hammer.Pan()
  //_pinch.recognizeWith(_rotate)
  //_pinch.recognizeWith(_pan)

  hammertime.on('pan', function(ev) {
    //console.log('pan', ev);
    if(ignore_next_pan) return;
    d = ev.distance
    current_panning[0] = base_panning[0]+Math.cos(to_rad(ev.angle))*d
    current_panning[1] = base_panning[1]-Math.sin(to_rad(ev.angle))*d
  });

  hammertime.on('panend', function(ev) {
    //console.log('pan', ev);
    if(ignore_next_pan) {ignore_next_pan = false; return;}
    d = ev.distance
    base_panning[0] += Math.cos(to_rad(ev.angle))*d
    base_panning[1] -= Math.sin(to_rad(ev.angle))*d
  });

  hammertime.on('pinchmove', function(ev) {
    //console.log('pinch', ev)
    let out = ev.additionalEvent == "pinchin" ? 1 : -1
    //current_scale[0] = base_scale[0] + Math.cos(to_rad(ev.angle))*ev.distance/100*out
    //current_scale[1] = base_scale[1] - Math.sin(to_rad(ev.angle))*ev.distance/100*out
    current_scale[0] = current_scale[1] = base_scale[0] + ev.distance*touch_pinch_factor*out
  });

  hammertime.on('pinchend', function(ev) {
    let out = ev.additionalEvent == "pinchin" ? 1 : -1
    base_scale[0] = base_scale[1] += ev.distance*touch_pinch_factor*out
    //base_scale[0] += Math.cos(to_rad(ev.angle))*ev.distance/100*out
    //base_scale[1] += Math.sin(to_rad(ev.angle))*ev.distance/100*out
    ignore_next_pan = true;
  });

  hammertime.on('rotatemove', function(ev) {
    current_rotation = ev.angle
  });

  hammertime.on('rotateend', function(ev) {
    base_rotation += ev.angle
    ignore_next_pan = true;
  });


  window.addEventListener("wheel", event => {
    let scroll_wheel_factor = 1/30
    current_scale[0] += Math.sign(event.deltaY)*scroll_wheel_factor
    current_scale[1] += Math.sign(event.deltaY)*scroll_wheel_factor
  });

  var gif = new GIF({workers: 4, quality: 30})
  gif.on('finished', function(blob) {
    window.open(URL.createObjectURL(blob));
    document.getElementById("gifResult").src = URL.createObjectURL(blob)
    console.log("Done giffing!")
  });
  gif.on('progress', function(p) {console.log(`${p*100}%`)})


  function addGifFrame(dt, regl){
    var width = reglCanvas.width
    var height = reglCanvas.height
    var data = regl.read({//This requires preserveDrawingBuffer and is thus pretty slow. Should figure out correct way! maybe use regl._gl
      x: 0,
      y: 0,
      width: width,
      height: height,
      data: new Uint8Array(width*height*4)
    })
    var canv2d = document.getElementById('gifCanvas')
    var context = canv2d.getContext('2d')
    canv2d.width = width
    canv2d.height = height
    var imageData = context.createImageData(width, height)
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0)
    gif.addFrame(canv2d, {copy: true, delay: dt})
  }

  const fileSelected = function(e) {
      const file = e.target.files[0]
      let reader = new FileReader()
      let img = new Image()

      reader.readAsDataURL(file)
      reader.onload = e => {img.src = e.target.result}
      toggleLoading()
      const t = Date.now()
      img.onload = ()=>{draw(img), console.log((Date.now()-t)/1000), toggleLoading()}
  }

  const change_style = e =>
  {
    var styleTag = document.getElementById("quicksettings_style");
	  if(e.value === "default") {
		  styleTag.href = "css/quicksettings.css";
	  }
	  else {
		  styleTag.href = "css/quicksettings_" + e.value + ".css";
	  }
  }

  const toggleLoading = function(){
      document.getElementById("loadingSpan").toggleAttribute("hidden")
  }

  const draw = (img) =>
  {
  // Calling regl() creates a new partially evaluated draw command
  let gl = reglCanvas.getContext('webgl', {preserveDrawingBuffer: true})
  var regl = createREGL(gl)
  //var original_texture = regl.texture(img)
  try {//FIXME instead of failing I shoudl downscale the image!!!
  var new_texture = regl.texture(img)
      new_texture.wrap = 'repeat'
      new_texture.mag = 'nearest'
      new_texture.min = 'nearest'
  } catch (e) {
    let max_texture_size = (gl.getParameter(gl.MAX_TEXTURE_SIZE))
    alert(
        "Maximal supported image size on this device is"+
        `${max_texture_size}x${max_texture_size}.\n`+
        `Your image has size ${img.height}x${img.width}.\n Sorry. Try on a PC.`
      )
  }
  //FIXME should set the canvas height/width ratio equal to the one of the loaded image.

  const crossPattern = regl({
  
    // Shaders in regl are just strings.  You can use glslify or whatever you want
    // to define them.  No need to manually create shader objects.
    frag: `
      precision mediump float; //FIXME should use regl attribute and not uniform
      uniform float combine_factor;
      uniform vec2 scale_factor;
      uniform float rotation_factor;
      uniform vec2 pan_factor;
      uniform float radial_splits;

      uniform vec2 u_resolution;
      uniform sampler2D texture_const;

      varying vec2 uv;

      const float E = 2.7182818284;
      const float PI = 3.1415926534;

      //Normalize pan_factor (FIXME maybe do in js part, as is only required once per frame....)
      vec2 pan = vec2 (pan_factor.x / u_resolution.x,
                        pan_factor.y / u_resolution.y);

      float random (vec2 st) {
        return fract(sin(dot(st.xy,
          vec2(12.9898,78.233)))*
          43758.5453123);
      }

      //FIXME more operations and should be normal functions!!
      #define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
      #define conjugate(a) vec2(a.x,-a.y)
      #define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))

      vec2 to_polar(vec2 v) {
        float r = sqrt(v.x*v.x + v.y*v.y);
        float phi = atan(v.y, v.x);
        return vec2(r, phi);
      }

      vec2 from_polar(vec2 pol) {
        vec2 ret;
        ret.x = cos(pol.y);
        ret.y = sin(pol.y);
        return ret*pol.x;
      }

      vec2 expi(vec2 c) {
        return vec2(cos(c.x), sin(c.x))*-exp(c.y);
      }

      vec2 expC(vec2 c) {
        return expi(divide(c, vec2(0,1)));
      }

      vec2 sinC(vec2 c) {
        vec2 res;
        res = expi(c) - expi(-c);
        return divide(res, vec2(0, 2));
      }

      vec2 cosC(vec2 c) {
        vec2 res;
        res = expi(c) + expi(-c);
        return divide(res, vec2(2, 0));
      }

      vec2 rotate(vec2 v, float a) {
        return vec2(
          cos(a)*v.x - sin(a)*v.y,
          sin(a)*v.x + cos(a)*v.y
        );
      }

      //TODO
      vec2 nth_root (vec2 v, float n) {
        vec2 pol = to_polar(v);
        v.y = pow(v.y, 1./n);
        return from_polar(v);
      }

      vec2 phi_mod (vec2 v, float phi) {
        vec2 pol = to_polar(v);
        pol.y = mod(pol.y, phi);
        return from_polar(pol);
      }

      vec2 one_over_z (vec2 v) {
        return divide(vec2(1,0), v);
      } 

      vec2 one_over_z_squared (vec2 v) {
        vec2 v2 = v*v;
        return divide(vec2(1,0), v2);
      } 

      void main() {
        //vec2 myUv = vec2 (uv.x, uv.y + combineFactor*0.1);
        vec2 pan_coord = pan+uv;
        pan_coord *= scale_factor;
        vec2 coord = pan_coord; //rotate(pan_coord, combineFactor*0.1);
        vec2 final_coord = coord;

        //vec2 final_coord = product(coord, coord)
          //+ vec2(mod(-combineFactor/2., 2.*3.14*10.), 0);
          //+ vec2(mod(-1./2., 2.*3.14*10.), 0);

        //final_coord = one_over_z(coord);
        final_coord = nth_root(divide(vec2(2,0), coord), 2.);
        //vec2 pol = to_polar(one_over_z(coord));
        //pol.y = mod(pol.y, PI/(pow(2., combineFactor/50.)));

        if(radial_splits > 0.)
          final_coord = phi_mod(final_coord, PI/radial_splits);

        //rotate the final_coords according to the rotation_factor
        //final_coord = rotate(final_coord, rotation_factor);
        //final_coord = from_polar(to_polar(coord)); //FIXME 
        //final_coord = coord;
        //final_coord = rotate(final_coord, -combineFactor*0.2);//vec2(pan_coord.x*pan_coord.x, pan_coord.y*pan_coord.y);

        final_coord = mix(pan_coord, final_coord, combine_factor);//FIXME I don\t think this is what I want to do here...
        gl_FragColor = texture2D(texture_const,
            vec2(
              mod(final_coord.x, 1.),
              mod(final_coord.y, 1.))
          );
      }`,
  
    vert: `
      precision mediump float;
      attribute vec2 position;
      varying vec2 uv;
      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
  
    // Here we define the vertex attributes for the above shader
    attributes: {
      // regl.buffer creates a new array buffer object
      position: regl.buffer([
        // no need to flatten nested arrays, regl automatically
        // unrolls them into a typedarray (default Float32)
        [-1, -1],   
        [-1, 1],
        [1, -1],    
        [1, -1],
        [1,  1],
        [-1, 1],
      ])
      // regl automatically infers sane defaults for the vertex attribute pointers
    },
  
    uniforms: {
      // This defines the color of the triangle to be a dynamic variable
      combine_factor: regl.prop('combine_factor'),
      scale_factor: regl.prop('scale_factor'),
      rotation_factor: regl.prop('rotation_factor'),
      pan_factor: regl.prop('pan_factor'),
      //These 2 should be made const...
      u_resolution: regl.prop('u_resolution'),
      radial_splits: regl.prop('radial_splits'),
      texture_const: new_texture,
    },
  
    // This tells regl the number of vertices to draw in this command
    count: 6
  })



  var fps60Gif = false;
  var to_gif = false;
  var i = 0
  var max_i = 5;//Math.floor(Math.PI*60)
  regl.frame(({time}) => {
    // clear contents of the drawing buffer
    //patch the GIF.JS to use https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels
    //if ctx is webgl/2

    regl.clear({
      color: [1, 0.5, 0, 0],
      depth: 1
    })
  
    // draw a triangle using the command defined above
    col = Math.random();
    crossPattern({
      combine_factor: settings.getValue("Strength"),//parseFloat(document.getElementById("combineRangeInput").value),
      u_resolution: [reglCanvas.width, reglCanvas.height], //not 100% correct
      color: [ col, col, col, 1 ],
      rotation_factor: to_rad(current_rotation + base_rotation),
      pan_factor: (current_panning),
      scale_factor: current_scale, //current_scale.map(x => {return x*x}) //really bad idea on mobile..
      radial_splits: settings.getValue("Split Radially")
    })

    if (to_gif && i++ < max_i && (i%2 == 0 && !fps60Gif || fps60Gif))
    {
      addGifFrame(fps60Gif ? 16 : 32, regl)
    }
    if(i == max_i)
    {
      console.log("Start giffing...")
      gif.render();
    }})}


    QuickSettings.useExtStyleSheet()
    var settings = QuickSettings.create(0, 0, "Settings", document.body)
    .setSize("120","")
    .addHTML("File:",
        "<input id='imageInput' type='file' accept='image/*' class='inputfile' onchange='fileSelected(event)'/>"+
        "<label for='imageInput'>Select Image!</label>"+
        "<span id='loadingSpan' hidden>Loading...</span>"
    )
    .addDropDown("Type", [
      "Z^-2",
      "Z^-1",
      "sqrt(Z)"
    ], undefined)
    .addRange("Strength", 0, 1, 1, 0.01, e => {})
    .addNumber("Split Radially", 0, 1/0, 0, 1, e => {})
    .addDropDown("style", [
					"default",
					"black",
					"white",
					"tiny",
					"tiny_white",
					"tiny_black"
        ], change_style)
    
    change_style({"value":"default"})
  </script>
</html>
